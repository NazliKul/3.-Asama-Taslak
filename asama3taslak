
import threading
import cv2
import numpy as np
import smbus2
import time 
def gstreamer_pipline(capture_width=640, capture_height=480, framerate=60, flip_method=0):
    return (
        "nvarguscamerasrc ! "
        "video/x-raw(memory:NVMM), width=(int)%d, height=(int)%d, framerate=(fraction)%d/1 ! "
        "nvvidconv flip-method=%d ! "
        "video/x-raw, width=(int)%d, height=(int)%d, format=(string)BGRx ! "
        "videoconvert ! "
        "video/x-raw, format=(string)BGR ! appsink"
        % (
            capture_width,
            capture_height,
            framerate,
            flip_method,
            capture_width,
            capture_height,
        )
    )
   
pipeline = gstreamer_pipeline()  
cap = cv2.VideoCapture(pipeline, cv2.CAP_GSTREAMER)





LIDAR_ADDR = 0x62  #ı2c ile iletisim icin gerekli olanlar
bus = smbus2.SMBus(1)

redlower = (0, 100, 100)#kırmızı renk 0 derece ve 360 derecede var oldugu icin iki ayrı aralik alinir
redupper = (10, 255, 255)
redlower2 = (160, 100, 100)
redupper2 = (180, 255, 255)

bluelower = (90, 120, 50) #mavi normalde tek aralıktadır ancak koyu ve açık mavi tespiti icin 2 renk araligi aliyoruz
blueupper = (110, 255, 255) 
bluelower2 = (110, 150, 50)
blueupper2 = (140, 255, 255)


def lidar_mesafe():
    bus.write_byte_data(LIDAR_ADDR, 0x00, 0x04)#olcumun basladigi yer
    time.sleep(0.02)#olcum icin bekleme suresi
    high = bus.read_byte_data(LIDAR_ADDR, 0x0f)#olcumun baytları okunuyor
    low = bus.read_byte_data(LIDAR_ADDR, 0x10)
    distance_mm = (high << 8) + low #mm olarak hesaplandi
    return distance_mm/100 #m'e cevirdim
def hiz_hesaplama():
    prev_dist = lidar_mesafe()#ilk mesafe degeri
    prev_time = time.time()#ilk zaman degeri aldık

    while True:
        curr_dist = lidar_mesafe() #lidar sensorunden anlık mesafe degerini alir 
        curr_time = time.time() #lidar sensorunden anlik zaman degisimini alir
        delta_dist = curr_dist - prev_dist #mesafe farkı alınıyor
        delta_time = curr_time - prev_time #zaman farki alınıyor

        if delta_time > 0:
            hiz = (delta_dist) / delta_time  #mesafe farkini zaman farkina bolerek hızı buluyoruz
            print(f"Mesafe: {curr_dist} m | Hız: {hiz:.2f} m/s")

        prev_dist, prev_time = curr_dist, curr_time
        time.sleep(0.1)
def nesne_hareketi():
    start_time = time.time()
    frame_count =0
    
    while True:
        ret, frame = cap.read()

        if ret:
            
            blurred = cv2.GaussianBlur(frame, (3, 3), 0)  
            hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)  
            
            mask_red1 = cv2.inRange(hsv, redlower, redupper) #kırmızı icin maskeleme yapiyoruz
            mask_red2 = cv2.inRange(hsv, redlower2, redupper2)
            mask_red = mask_red1 | mask_red2 #iki maskeyi birlestiriyoruz
            mask_red = cv2.erode(mask_red, None, iterations=2)#erode ile gurultuleri engelliyoruz
            dusman = cv2.bitwise_and(frame, frame, mask=mask_red)

           
            mask_blue1 = cv2.inRange(hsv, bluelower, blueupper) #mavi renkler icin maskeleme islemi yapiyoruz
            mask_blue2 = cv2.inRange(hsv, bluelower2, blueupper2)
            mask_blue = mask_blue1 | mask_blue2 #iki maskeyi birlestirdim
            mask_blue = cv2.erode(mask_blue, None, iterations=2)
            dost = cv2.bitwise_and(frame, frame, mask=mask_blue) #bitwise ile birlestirdigim maskeyi dosta esitliyorum
            
            cv2.imshow("Dusman", dusman)
            cv2.imshow("Dost", dost)
            
            (contours_red, _) = cv2.findContours(mask_red.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)#konturleme islemini yapiyorum
            
            frame_count +=1
            elapsed_time =time.time()-start_time
            if elapsed_time >1:
                fps = frame_count/elapsed_time
                print(f"Anlık fps:{fps:.2f}")
                start_time=time.time()
                frame_count=0
          

            
            if len(contours_red) > 0: #eger konturum kırmızı icinse
                c = max(contours_red, key=cv2.contourArea)
                rect = cv2.minAreaRect(c)
                ((x, y), (width, height), rotation) = rect
                box = np.int32(cv2.boxPoints(rect))

                M = cv2.moments(c)
                if M["m00"] != 0:
                    center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
                    cv2.drawContours(frame, [box], 0, (0, 255, 0), 2)
                    cv2.circle(frame, center, 5, (0, 255, 0), -1)
                    cv2.putText(frame, "Dusman", (int(x - width / 2), int(y - height / 2) - 10), cv2.FONT_HERSHEY_COMPLEX, 0.8, (0, 255, 0), 2)

           
            (contours_blue, _) = cv2.findContours(mask_blue.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            if len(contours_blue) > 0:
                c = max(contours_blue, key=cv2.contourArea)
                rect = cv2.minAreaRect(c)
                ((x, y), (width, height), rotation) = rect
                box = np.int32(cv2.boxPoints(rect))

                M = cv2.moments(c)
                if M["m00"] != 0:
                    center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
                    cv2.drawContours(frame, [box], 0, (255, 0, 0), 2)  
                    cv2.circle(frame, center, 5, (255, 0, 0), -1)
                    cv2.putText(frame, "Dost", (int(x - width / 2), int(y - height / 2) - 10), cv2.FONT_HERSHEY_COMPLEX, 0.8, (255, 0, 0), 2)          
          
            cv2.imshow("Orijinal", frame)
            if cv2.waitKey(1)==ord("q"):
                break
          

def main():#iki fonksiyonu paralel olarak islemek icin main fonksiyonunu kullanıyorum.
       nesne_thread=threading.Thread(target=nesne_hareketi)
       lidar_thread=threading.Thread(target=hiz_hesaplama)
       
       nesne_thread.start()
       lidar_thread.start()
       
       nesne_thread.join()
       lidar_thread.join()
       
       cap.release()
       cv2.destroyAllWindows()
       
try :
    main()
except KeyboardInterrupt:
    print("program sonlandirildi")
    bus.close()
